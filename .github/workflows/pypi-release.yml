name: PyPI Release

on:
  pull_request:
    types:
      - closed

permissions:
  contents: write  # Required to push commits, tags, and create releases
  pull-requests: read  # Required to read PR information

jobs:
  check_version:
    name: Determine Next Version
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.determine-version.outputs.new_version }}
      version_changed: ${{ steps.determine-version.outputs.version_changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install dependencies
        run: python -m pip install tomli

      - name: Determine next version
        id: determine-version
        run: |
          # Extract the branch prefix from the PR's base ref
          branch="${{ github.event.pull_request.head.ref }}"
          echo "Branch: $branch"

          # Get current version from pyproject.toml for fallback
          cat > get_version.py << 'EOL'
          import tomli

          with open("pyproject.toml", "rb") as f:
              data = tomli.load(f)
          print(data["project"]["version"])
          EOL

          CURRENT_VERSION=$(python get_version.py)
          echo "Current version in pyproject.toml: $CURRENT_VERSION"

          # Get latest tag
          git fetch --tags

          # Check if any tags exist
          if git tag -l "v*" | grep -q .; then
            latest_tag=$(git tag -l "v*" | sort -V | tail -n 1)
          else
            latest_tag="v$CURRENT_VERSION"
            echo "No existing tags found, using current version from pyproject.toml"
          fi

          echo "Latest tag: $latest_tag"

          # Remove 'v' prefix
          latest_version=${latest_tag#v}
          echo "Latest version: $latest_version"

          # Split version into components
          IFS='.' read -r major minor patch <<< "$latest_version"

          # Ensure we have valid numeric values
          major=${major:-0}
          minor=${minor:-1}
          patch=${patch:-0}

          echo "Current components: major=$major, minor=$minor, patch=$patch"

          # Default to no change
          version_changed=false

          # Determine new version based on branch prefix (Correlator conventions)
          if [[ $branch == "minor/"* ]]; then
            minor=$((minor + 1))
            patch=0
            version_changed=true
            echo "Minor branch - incrementing minor version"
          elif [[ $branch == "patch/"* ]]; then
            patch=$((patch + 1))
            version_changed=true
            echo "Patch branch - incrementing patch version"
          elif [[ $branch == "major/"* ]]; then
            major=$((major + 1))
            minor=0
            patch=0
            version_changed=true
            echo "Major branch - incrementing major version"
          else
            # No version change for other branch types (chore, etc.)
            echo "Branch prefix '$branch' does not affect versioning"
          fi

          new_version="$major.$minor.$patch"
          echo "New version: $new_version"

          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "version_changed=$version_changed" >> $GITHUB_OUTPUT

  release:
    name: Build and Release
    needs: [check_version]
    if: needs.check_version.outputs.version_changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0

      - name: Set up Git
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install UV
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install tomli tomli-w

      - name: Update version in pyproject.toml
        run: |
          NEW_VERSION="${{ needs.check_version.outputs.new_version }}"
          echo "Updating pyproject.toml to version $NEW_VERSION"

          # Use Python to update version in pyproject.toml
          cat > update_version.py << 'EOL'
          import tomli
          import tomli_w
          import sys

          # Get new version from command line
          new_version = sys.argv[1]

          # Read pyproject.toml
          with open("pyproject.toml", "rb") as f:
              data = tomli.load(f)

          # Update version
          data["project"]["version"] = new_version

          # Write updated data back
          with open("pyproject.toml", "wb") as f:
              tomli_w.dump(data, f)
          EOL

          # Update the version
          python update_version.py "$NEW_VERSION"

      - name: Commit and tag version change
        run: |
          NEW_VERSION="${{ needs.check_version.outputs.new_version }}"

          # Check if tag already exists (handles re-run after partial failure)
          if git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "⚠️ Tag v$NEW_VERSION already exists, skipping commit and tag creation"
            echo "This is expected if re-running after a partial failure"
          else
            git add pyproject.toml
            git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
            git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
            git push
            git push --tags
            echo "✅ Created and pushed tag v$NEW_VERSION"
          fi

      - name: Install project dependencies
        run: |
          uv venv
          source .venv/bin/activate
          uv pip install -e ".[dev]"

      - name: Run tests
        run: make run test

      - name: Build package
        run: make build

      - name: Extract changelog for version
        run: |
          NEW_VERSION="${{ needs.check_version.outputs.new_version }}"
          echo "Extracting changelog for version $NEW_VERSION"

          # Extract the section for this version from CHANGELOG.md
          # Matches from "## [X.Y.Z]" until the next "## [" or end of file
          # PR checks enforce changelog entry exists before merge
          awk -v ver="$NEW_VERSION" '
            /^## \[/ {
              if (found) exit
              if ($0 ~ "\\[" ver "\\]") found=1
            }
            found { print }
          ' CHANGELOG.md > release_notes.md

          echo "Extracted changelog:"
          cat release_notes.md

      - name: Publish to PyPI
        run: |
          uv publish \
            --token ${{ secrets.PYPI_API_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.check_version.outputs.new_version }}
          name: Release v${{ needs.check_version.outputs.new_version }}
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
